/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.0 Wed Apr 10 14:17:48 2024.
 */

#include <string.h>

#include "inu.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint64_t unpack_left_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

static inline uint64_t unpack_right_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) >> shift);
}

int inu_latitude_pack(
    uint8_t *dst_p,
    const struct inu_latitude_t *src_p,
    size_t size)
{
    uint64_t pos_lat2;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    pos_lat2 = (uint64_t)src_p->pos_lat2;
    dst_p[0] |= pack_right_shift_u64(pos_lat2, 56u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(pos_lat2, 48u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(pos_lat2, 40u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(pos_lat2, 32u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(pos_lat2, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(pos_lat2, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(pos_lat2, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u64(pos_lat2, 0u, 0xffu);

    return (8);
}

int inu_latitude_unpack(
    struct inu_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t pos_lat2;

    if (size < 8u) {
        return (-EINVAL);
    }

    pos_lat2 = unpack_left_shift_u64(src_p[0], 56u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[1], 48u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[2], 40u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[3], 32u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[4], 24u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[5], 16u, 0xffu);
    pos_lat2 |= unpack_left_shift_u64(src_p[6], 8u, 0xffu);
    pos_lat2 |= unpack_right_shift_u64(src_p[7], 0u, 0xffu);
    dst_p->pos_lat2 = (int64_t)pos_lat2;

    return (0);
}

int inu_latitude_init(struct inu_latitude_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_latitude_t));

    return 0;
}

int64_t inu_latitude_pos_lat2_encode(double value)
{
    return (int64_t)(value / 1e-08);
}

double inu_latitude_pos_lat2_decode(int64_t value)
{
    return ((double)value * 1e-08);
}

bool inu_latitude_pos_lat2_is_in_range(int64_t value)
{
    return ((value >= -9000000000ll) && (value <= 9000000000ll));
}

int inu_longitude_pack(
    uint8_t *dst_p,
    const struct inu_longitude_t *src_p,
    size_t size)
{
    uint64_t pos_lon2;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    pos_lon2 = (uint64_t)src_p->pos_lon2;
    dst_p[0] |= pack_right_shift_u64(pos_lon2, 56u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(pos_lon2, 48u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(pos_lon2, 40u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(pos_lon2, 32u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(pos_lon2, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(pos_lon2, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(pos_lon2, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u64(pos_lon2, 0u, 0xffu);

    return (8);
}

int inu_longitude_unpack(
    struct inu_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t pos_lon2;

    if (size < 8u) {
        return (-EINVAL);
    }

    pos_lon2 = unpack_left_shift_u64(src_p[0], 56u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[1], 48u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[2], 40u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[3], 32u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[4], 24u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[5], 16u, 0xffu);
    pos_lon2 |= unpack_left_shift_u64(src_p[6], 8u, 0xffu);
    pos_lon2 |= unpack_right_shift_u64(src_p[7], 0u, 0xffu);
    dst_p->pos_lon2 = (int64_t)pos_lon2;

    return (0);
}

int inu_longitude_init(struct inu_longitude_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_longitude_t));

    return 0;
}

int64_t inu_longitude_pos_lon2_encode(double value)
{
    return (int64_t)(value / 1e-08);
}

double inu_longitude_pos_lon2_decode(int64_t value)
{
    return ((double)value * 1e-08);
}

bool inu_longitude_pos_lon2_is_in_range(int64_t value)
{
    return ((value >= -18000000000ll) && (value <= 18000000000ll));
}

int inu_ang_rate_vehicle_pack(
    uint8_t *dst_p,
    const struct inu_ang_rate_vehicle_t *src_p,
    size_t size)
{
    uint32_t ang_rate_x;
    uint32_t ang_rate_y;
    uint32_t ang_rate_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    ang_rate_x = (uint32_t)src_p->ang_rate_x;
    dst_p[0] |= pack_right_shift_u32(ang_rate_x, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(ang_rate_x, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(ang_rate_x, 4u, 0xf0u);
    ang_rate_y = (uint32_t)src_p->ang_rate_y;
    dst_p[2] |= pack_right_shift_u32(ang_rate_y, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(ang_rate_y, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(ang_rate_y, 0u, 0xffu);
    ang_rate_z = (uint32_t)src_p->ang_rate_z;
    dst_p[5] |= pack_right_shift_u32(ang_rate_z, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(ang_rate_z, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(ang_rate_z, 4u, 0xf0u);

    return (8);
}

int inu_ang_rate_vehicle_unpack(
    struct inu_ang_rate_vehicle_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t ang_rate_x;
    uint32_t ang_rate_y;
    uint32_t ang_rate_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    ang_rate_x = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    ang_rate_x |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    ang_rate_x |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);

    if ((ang_rate_x & (1u << 19)) != 0u) {
        ang_rate_x |= 0xfff00000u;
    }

    dst_p->ang_rate_x = (int32_t)ang_rate_x;
    ang_rate_y = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    ang_rate_y |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    ang_rate_y |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);

    if ((ang_rate_y & (1u << 19)) != 0u) {
        ang_rate_y |= 0xfff00000u;
    }

    dst_p->ang_rate_y = (int32_t)ang_rate_y;
    ang_rate_z = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    ang_rate_z |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    ang_rate_z |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    if ((ang_rate_z & (1u << 19)) != 0u) {
        ang_rate_z |= 0xfff00000u;
    }

    dst_p->ang_rate_z = (int32_t)ang_rate_z;

    return (0);
}

int inu_ang_rate_vehicle_init(struct inu_ang_rate_vehicle_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_ang_rate_vehicle_t));

    return 0;
}

int32_t inu_ang_rate_vehicle_ang_rate_x_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_vehicle_ang_rate_x_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_vehicle_ang_rate_x_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}

int32_t inu_ang_rate_vehicle_ang_rate_y_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_vehicle_ang_rate_y_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_vehicle_ang_rate_y_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}

int32_t inu_ang_rate_vehicle_ang_rate_z_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_vehicle_ang_rate_z_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_vehicle_ang_rate_z_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}

int inu_heading_pitch_roll_sigma_pack(
    uint8_t *dst_p,
    const struct inu_heading_pitch_roll_sigma_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->angle_heading_sigma, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->angle_heading_sigma, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->angle_heading_sigma, 4u, 0xf0u);
    dst_p[2] |= pack_right_shift_u32(src_p->angle_pitch_sigma, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(src_p->angle_pitch_sigma, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->angle_pitch_sigma, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->angle_roll_sigma, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->angle_roll_sigma, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->angle_roll_sigma, 4u, 0xf0u);

    return (8);
}

int inu_heading_pitch_roll_sigma_unpack(
    struct inu_heading_pitch_roll_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->angle_heading_sigma = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    dst_p->angle_heading_sigma |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    dst_p->angle_heading_sigma |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);
    dst_p->angle_pitch_sigma = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    dst_p->angle_pitch_sigma |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->angle_pitch_sigma |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->angle_roll_sigma = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    dst_p->angle_roll_sigma |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    dst_p->angle_roll_sigma |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    return (0);
}

int inu_heading_pitch_roll_sigma_init(struct inu_heading_pitch_roll_sigma_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_heading_pitch_roll_sigma_t));

    return 0;
}

uint32_t inu_heading_pitch_roll_sigma_angle_heading_sigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_heading_pitch_roll_sigma_angle_heading_sigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_heading_pitch_roll_sigma_angle_heading_sigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

uint32_t inu_heading_pitch_roll_sigma_angle_pitch_sigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_heading_pitch_roll_sigma_angle_pitch_sigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_heading_pitch_roll_sigma_angle_pitch_sigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

uint32_t inu_heading_pitch_roll_sigma_angle_roll_sigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_heading_pitch_roll_sigma_angle_roll_sigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_heading_pitch_roll_sigma_angle_roll_sigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

int inu_heading_pitch_roll_pack(
    uint8_t *dst_p,
    const struct inu_heading_pitch_roll_t *src_p,
    size_t size)
{
    uint16_t angle_pitch;
    uint16_t angle_roll;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_right_shift_u16(src_p->angle_heading, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->angle_heading, 0u, 0xffu);
    angle_pitch = (uint16_t)src_p->angle_pitch;
    dst_p[2] |= pack_right_shift_u16(angle_pitch, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(angle_pitch, 0u, 0xffu);
    angle_roll = (uint16_t)src_p->angle_roll;
    dst_p[4] |= pack_right_shift_u16(angle_roll, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(angle_roll, 0u, 0xffu);

    return (6);
}

int inu_heading_pitch_roll_unpack(
    struct inu_heading_pitch_roll_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t angle_pitch;
    uint16_t angle_roll;

    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->angle_heading = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->angle_heading |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    angle_pitch = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    angle_pitch |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->angle_pitch = (int16_t)angle_pitch;
    angle_roll = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    angle_roll |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->angle_roll = (int16_t)angle_roll;

    return (0);
}

int inu_heading_pitch_roll_init(struct inu_heading_pitch_roll_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_heading_pitch_roll_t));

    return 0;
}

uint16_t inu_heading_pitch_roll_angle_heading_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double inu_heading_pitch_roll_angle_heading_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool inu_heading_pitch_roll_angle_heading_is_in_range(uint16_t value)
{
    return (value <= 36000u);
}

int16_t inu_heading_pitch_roll_angle_pitch_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_heading_pitch_roll_angle_pitch_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_heading_pitch_roll_angle_pitch_is_in_range(int16_t value)
{
    return ((value >= -9000) && (value <= 9000));
}

int16_t inu_heading_pitch_roll_angle_roll_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_heading_pitch_roll_angle_roll_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_heading_pitch_roll_angle_roll_is_in_range(int16_t value)
{
    return ((value >= -18000) && (value <= 18000));
}

int inu_accel_vehicle_pack(
    uint8_t *dst_p,
    const struct inu_accel_vehicle_t *src_p,
    size_t size)
{
    uint32_t accel_x;
    uint32_t accel_y;
    uint32_t accel_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    accel_x = (uint32_t)src_p->accel_x;
    dst_p[0] |= pack_right_shift_u32(accel_x, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(accel_x, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(accel_x, 4u, 0xf0u);
    accel_y = (uint32_t)src_p->accel_y;
    dst_p[2] |= pack_right_shift_u32(accel_y, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(accel_y, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(accel_y, 0u, 0xffu);
    accel_z = (uint32_t)src_p->accel_z;
    dst_p[5] |= pack_right_shift_u32(accel_z, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(accel_z, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(accel_z, 4u, 0xf0u);

    return (8);
}

int inu_accel_vehicle_unpack(
    struct inu_accel_vehicle_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t accel_x;
    uint32_t accel_y;
    uint32_t accel_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    accel_x = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    accel_x |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    accel_x |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);

    if ((accel_x & (1u << 19)) != 0u) {
        accel_x |= 0xfff00000u;
    }

    dst_p->accel_x = (int32_t)accel_x;
    accel_y = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    accel_y |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    accel_y |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);

    if ((accel_y & (1u << 19)) != 0u) {
        accel_y |= 0xfff00000u;
    }

    dst_p->accel_y = (int32_t)accel_y;
    accel_z = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    accel_z |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    accel_z |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    if ((accel_z & (1u << 19)) != 0u) {
        accel_z |= 0xfff00000u;
    }

    dst_p->accel_z = (int32_t)accel_z;

    return (0);
}

int inu_accel_vehicle_init(struct inu_accel_vehicle_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_accel_vehicle_t));

    return 0;
}

int32_t inu_accel_vehicle_accel_x_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_vehicle_accel_x_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_vehicle_accel_x_is_in_range(int32_t value)
{
    return ((value >= -80000) && (value <= 80000));
}

int32_t inu_accel_vehicle_accel_y_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_vehicle_accel_y_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_vehicle_accel_y_is_in_range(int32_t value)
{
    return ((value >= -80000) && (value <= 80000));
}

int32_t inu_accel_vehicle_accel_z_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_vehicle_accel_z_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_vehicle_accel_z_is_in_range(int32_t value)
{
    return ((value >= -80000) && (value <= 80000));
}

int inu_velocity_level_sigma_pack(
    uint8_t *dst_p,
    const struct inu_velocity_level_sigma_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->vel_e_sigma, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->vel_e_sigma, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->vel_n_sigma, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->vel_n_sigma, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->vel_u_sigma, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->vel_u_sigma, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->vel_sigma, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->vel_sigma, 0u, 0xffu);

    return (8);
}

int inu_velocity_level_sigma_unpack(
    struct inu_velocity_level_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->vel_e_sigma = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->vel_e_sigma |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->vel_n_sigma = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->vel_n_sigma |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->vel_u_sigma = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->vel_u_sigma |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->vel_sigma = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->vel_sigma |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int inu_velocity_level_sigma_init(struct inu_velocity_level_sigma_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_velocity_level_sigma_t));

    return 0;
}

uint16_t inu_velocity_level_sigma_vel_e_sigma_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double inu_velocity_level_sigma_vel_e_sigma_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool inu_velocity_level_sigma_vel_e_sigma_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t inu_velocity_level_sigma_vel_n_sigma_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double inu_velocity_level_sigma_vel_n_sigma_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool inu_velocity_level_sigma_vel_n_sigma_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t inu_velocity_level_sigma_vel_u_sigma_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double inu_velocity_level_sigma_vel_u_sigma_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool inu_velocity_level_sigma_vel_u_sigma_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t inu_velocity_level_sigma_vel_sigma_encode(double value)
{
    return (uint16_t)(value / 0.001);
}

double inu_velocity_level_sigma_vel_sigma_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool inu_velocity_level_sigma_vel_sigma_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int inu_time_pack(
    uint8_t *dst_p,
    const struct inu_time_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    dst_p[0] |= pack_right_shift_u16(src_p->gps_week, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->gps_week, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->gps_time, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->gps_time, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u32(src_p->gps_time, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u32(src_p->gps_time, 0u, 0xffu);

    return (6);
}

int inu_time_unpack(
    struct inu_time_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 6u) {
        return (-EINVAL);
    }

    dst_p->gps_week = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->gps_week |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->gps_time = unpack_left_shift_u32(src_p[2], 24u, 0xffu);
    dst_p->gps_time |= unpack_left_shift_u32(src_p[3], 16u, 0xffu);
    dst_p->gps_time |= unpack_left_shift_u32(src_p[4], 8u, 0xffu);
    dst_p->gps_time |= unpack_right_shift_u32(src_p[5], 0u, 0xffu);

    return (0);
}

int inu_time_init(struct inu_time_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_time_t));

    return 0;
}

uint16_t inu_time_gps_week_encode(double value)
{
    return (uint16_t)(value);
}

double inu_time_gps_week_decode(uint16_t value)
{
    return ((double)value);
}

bool inu_time_gps_week_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint32_t inu_time_gps_time_encode(double value)
{
    return (uint32_t)(value / 0.001);
}

double inu_time_gps_time_decode(uint32_t value)
{
    return ((double)value * 0.001);
}

bool inu_time_gps_time_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int inu_velocity_level_pack(
    uint8_t *dst_p,
    const struct inu_velocity_level_t *src_p,
    size_t size)
{
    uint16_t vel;
    uint16_t vel_e;
    uint16_t vel_n;
    uint16_t vel_u;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    vel_e = (uint16_t)src_p->vel_e;
    dst_p[0] |= pack_right_shift_u16(vel_e, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(vel_e, 0u, 0xffu);
    vel_n = (uint16_t)src_p->vel_n;
    dst_p[2] |= pack_right_shift_u16(vel_n, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(vel_n, 0u, 0xffu);
    vel_u = (uint16_t)src_p->vel_u;
    dst_p[4] |= pack_right_shift_u16(vel_u, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(vel_u, 0u, 0xffu);
    vel = (uint16_t)src_p->vel;
    dst_p[6] |= pack_right_shift_u16(vel, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(vel, 0u, 0xffu);

    return (8);
}

int inu_velocity_level_unpack(
    struct inu_velocity_level_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t vel;
    uint16_t vel_e;
    uint16_t vel_n;
    uint16_t vel_u;

    if (size < 8u) {
        return (-EINVAL);
    }

    vel_e = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    vel_e |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->vel_e = (int16_t)vel_e;
    vel_n = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    vel_n |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->vel_n = (int16_t)vel_n;
    vel_u = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    vel_u |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->vel_u = (int16_t)vel_u;
    vel = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    vel |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->vel = (int16_t)vel;

    return (0);
}

int inu_velocity_level_init(struct inu_velocity_level_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_velocity_level_t));

    return 0;
}

int16_t inu_velocity_level_vel_e_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_velocity_level_vel_e_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_velocity_level_vel_e_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t inu_velocity_level_vel_n_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_velocity_level_vel_n_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_velocity_level_vel_n_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t inu_velocity_level_vel_u_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_velocity_level_vel_u_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_velocity_level_vel_u_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t inu_velocity_level_vel_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double inu_velocity_level_vel_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool inu_velocity_level_vel_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int inu_pos_sigma_pack(
    uint8_t *dst_p,
    const struct inu_pos_sigma_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u32(src_p->pos_e_sigma, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->pos_e_sigma, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(src_p->pos_e_sigma, 4u, 0xf0u);
    dst_p[2] |= pack_right_shift_u32(src_p->pos_nsigma, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(src_p->pos_nsigma, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->pos_nsigma, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->pos_usigma, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->pos_usigma, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(src_p->pos_usigma, 4u, 0xf0u);

    return (8);
}

int inu_pos_sigma_unpack(
    struct inu_pos_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->pos_e_sigma = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    dst_p->pos_e_sigma |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    dst_p->pos_e_sigma |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);
    dst_p->pos_nsigma = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    dst_p->pos_nsigma |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    dst_p->pos_nsigma |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->pos_usigma = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    dst_p->pos_usigma |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    dst_p->pos_usigma |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    return (0);
}

int inu_pos_sigma_init(struct inu_pos_sigma_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_pos_sigma_t));

    return 0;
}

uint32_t inu_pos_sigma_pos_e_sigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_pos_sigma_pos_e_sigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_pos_sigma_pos_e_sigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

uint32_t inu_pos_sigma_pos_nsigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_pos_sigma_pos_nsigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_pos_sigma_pos_nsigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

uint32_t inu_pos_sigma_pos_usigma_encode(double value)
{
    return (uint32_t)(value / 0.0001);
}

double inu_pos_sigma_pos_usigma_decode(uint32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_pos_sigma_pos_usigma_is_in_range(uint32_t value)
{
    return (value <= 1000000u);
}

int inu_altitude_pack(
    uint8_t *dst_p,
    const struct inu_altitude_t *src_p,
    size_t size)
{
    uint32_t pos_alt;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    pos_alt = (uint32_t)src_p->pos_alt;
    dst_p[0] |= pack_right_shift_u32(pos_alt, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_alt, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_alt, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(pos_alt, 0u, 0xffu);

    return (4);
}

int inu_altitude_unpack(
    struct inu_altitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_alt;

    if (size < 4u) {
        return (-EINVAL);
    }

    pos_alt = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    pos_alt |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    pos_alt |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    pos_alt |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->pos_alt = (int32_t)pos_alt;

    return (0);
}

int inu_altitude_init(struct inu_altitude_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_altitude_t));

    return 0;
}

int32_t inu_altitude_pos_alt_encode(double value)
{
    return (int32_t)(value / 0.001);
}

double inu_altitude_pos_alt_decode(int32_t value)
{
    return ((double)value * 0.001);
}

bool inu_altitude_pos_alt_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int inu_latitude_longitude_pack(
    uint8_t *dst_p,
    const struct inu_latitude_longitude_t *src_p,
    size_t size)
{
    uint32_t pos_lat;
    uint32_t pos_lon;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    pos_lat = (uint32_t)src_p->pos_lat;
    dst_p[0] |= pack_right_shift_u32(pos_lat, 24u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pos_lat, 16u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pos_lat, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u32(pos_lat, 0u, 0xffu);
    pos_lon = (uint32_t)src_p->pos_lon;
    dst_p[4] |= pack_right_shift_u32(pos_lon, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(pos_lon, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(pos_lon, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(pos_lon, 0u, 0xffu);

    return (8);
}

int inu_latitude_longitude_unpack(
    struct inu_latitude_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pos_lat;
    uint32_t pos_lon;

    if (size < 8u) {
        return (-EINVAL);
    }

    pos_lat = unpack_left_shift_u32(src_p[0], 24u, 0xffu);
    pos_lat |= unpack_left_shift_u32(src_p[1], 16u, 0xffu);
    pos_lat |= unpack_left_shift_u32(src_p[2], 8u, 0xffu);
    pos_lat |= unpack_right_shift_u32(src_p[3], 0u, 0xffu);
    dst_p->pos_lat = (int32_t)pos_lat;
    pos_lon = unpack_left_shift_u32(src_p[4], 24u, 0xffu);
    pos_lon |= unpack_left_shift_u32(src_p[5], 16u, 0xffu);
    pos_lon |= unpack_left_shift_u32(src_p[6], 8u, 0xffu);
    pos_lon |= unpack_right_shift_u32(src_p[7], 0u, 0xffu);
    dst_p->pos_lon = (int32_t)pos_lon;

    return (0);
}

int inu_latitude_longitude_init(struct inu_latitude_longitude_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_latitude_longitude_t));

    return 0;
}

int32_t inu_latitude_longitude_pos_lat_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double inu_latitude_longitude_pos_lat_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool inu_latitude_longitude_pos_lat_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int32_t inu_latitude_longitude_pos_lon_encode(double value)
{
    return (int32_t)(value / 1e-07);
}

double inu_latitude_longitude_pos_lon_decode(int32_t value)
{
    return ((double)value * 1e-07);
}

bool inu_latitude_longitude_pos_lon_is_in_range(int32_t value)
{
    (void)value;

    return (true);
}

int inu_ins_status_pack(
    uint8_t *dst_p,
    const struct inu_ins_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->system_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->gps_num_sats_used, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->satellite_status, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->gps_num_sats2_used, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->gps_age, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->gps_age, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->gps_num_sats, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->gps_num_sats2, 0u, 0xffu);

    return (8);
}

int inu_ins_status_unpack(
    struct inu_ins_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->system_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->gps_num_sats_used = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->satellite_status = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->gps_num_sats2_used = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->gps_age = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->gps_age |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->gps_num_sats = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->gps_num_sats2 = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int inu_ins_status_init(struct inu_ins_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_ins_status_t));

    return 0;
}

uint8_t inu_ins_status_system_state_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_system_state_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_system_state_is_in_range(uint8_t value)
{
    return (value <= 9u);
}

uint8_t inu_ins_status_gps_num_sats_used_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_gps_num_sats_used_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_gps_num_sats_used_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t inu_ins_status_satellite_status_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_satellite_status_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_satellite_status_is_in_range(uint8_t value)
{
    return (value <= 9u);
}

uint8_t inu_ins_status_gps_num_sats2_used_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_gps_num_sats2_used_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_gps_num_sats2_used_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t inu_ins_status_gps_age_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double inu_ins_status_gps_age_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool inu_ins_status_gps_age_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t inu_ins_status_gps_num_sats_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_gps_num_sats_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_gps_num_sats_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t inu_ins_status_gps_num_sats2_encode(double value)
{
    return (uint8_t)(value);
}

double inu_ins_status_gps_num_sats2_decode(uint8_t value)
{
    return ((double)value);
}

bool inu_ins_status_gps_num_sats2_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int inu_accel_imu_raw_pack(
    uint8_t *dst_p,
    const struct inu_accel_imu_raw_t *src_p,
    size_t size)
{
    uint32_t accel_raw_x;
    uint32_t accel_raw_y;
    uint32_t accel_raw_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    accel_raw_x = (uint32_t)src_p->accel_raw_x;
    dst_p[0] |= pack_right_shift_u32(accel_raw_x, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(accel_raw_x, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(accel_raw_x, 4u, 0xf0u);
    accel_raw_y = (uint32_t)src_p->accel_raw_y;
    dst_p[2] |= pack_right_shift_u32(accel_raw_y, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(accel_raw_y, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(accel_raw_y, 0u, 0xffu);
    accel_raw_z = (uint32_t)src_p->accel_raw_z;
    dst_p[5] |= pack_right_shift_u32(accel_raw_z, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(accel_raw_z, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(accel_raw_z, 4u, 0xf0u);

    return (8);
}

int inu_accel_imu_raw_unpack(
    struct inu_accel_imu_raw_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t accel_raw_x;
    uint32_t accel_raw_y;
    uint32_t accel_raw_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    accel_raw_x = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    accel_raw_x |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    accel_raw_x |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);

    if ((accel_raw_x & (1u << 19)) != 0u) {
        accel_raw_x |= 0xfff00000u;
    }

    dst_p->accel_raw_x = (int32_t)accel_raw_x;
    accel_raw_y = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    accel_raw_y |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    accel_raw_y |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);

    if ((accel_raw_y & (1u << 19)) != 0u) {
        accel_raw_y |= 0xfff00000u;
    }

    dst_p->accel_raw_y = (int32_t)accel_raw_y;
    accel_raw_z = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    accel_raw_z |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    accel_raw_z |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    if ((accel_raw_z & (1u << 19)) != 0u) {
        accel_raw_z |= 0xfff00000u;
    }

    dst_p->accel_raw_z = (int32_t)accel_raw_z;

    return (0);
}

int inu_accel_imu_raw_init(struct inu_accel_imu_raw_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_accel_imu_raw_t));

    return 0;
}

int32_t inu_accel_imu_raw_accel_raw_x_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_imu_raw_accel_raw_x_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_imu_raw_accel_raw_x_is_in_range(int32_t value)
{
    return ((value >= -500000) && (value <= 500000));
}

int32_t inu_accel_imu_raw_accel_raw_y_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_imu_raw_accel_raw_y_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_imu_raw_accel_raw_y_is_in_range(int32_t value)
{
    return ((value >= -500000) && (value <= 500000));
}

int32_t inu_accel_imu_raw_accel_raw_z_encode(double value)
{
    return (int32_t)(value / 0.0001);
}

double inu_accel_imu_raw_accel_raw_z_decode(int32_t value)
{
    return ((double)value * 0.0001);
}

bool inu_accel_imu_raw_accel_raw_z_is_in_range(int32_t value)
{
    return ((value >= -500000) && (value <= 500000));
}

int inu_ang_rate_raw_imu_pack(
    uint8_t *dst_p,
    const struct inu_ang_rate_raw_imu_t *src_p,
    size_t size)
{
    uint32_t ang_rate_raw_x;
    uint32_t ang_rate_raw_y;
    uint32_t ang_rate_raw_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    ang_rate_raw_x = (uint32_t)src_p->ang_rate_raw_x;
    dst_p[0] |= pack_right_shift_u32(ang_rate_raw_x, 12u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(ang_rate_raw_x, 4u, 0xffu);
    dst_p[2] |= pack_left_shift_u32(ang_rate_raw_x, 4u, 0xf0u);
    ang_rate_raw_y = (uint32_t)src_p->ang_rate_raw_y;
    dst_p[2] |= pack_right_shift_u32(ang_rate_raw_y, 16u, 0x0fu);
    dst_p[3] |= pack_right_shift_u32(ang_rate_raw_y, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(ang_rate_raw_y, 0u, 0xffu);
    ang_rate_raw_z = (uint32_t)src_p->ang_rate_raw_z;
    dst_p[5] |= pack_right_shift_u32(ang_rate_raw_z, 12u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(ang_rate_raw_z, 4u, 0xffu);
    dst_p[7] |= pack_left_shift_u32(ang_rate_raw_z, 4u, 0xf0u);

    return (8);
}

int inu_ang_rate_raw_imu_unpack(
    struct inu_ang_rate_raw_imu_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t ang_rate_raw_x;
    uint32_t ang_rate_raw_y;
    uint32_t ang_rate_raw_z;

    if (size < 8u) {
        return (-EINVAL);
    }

    ang_rate_raw_x = unpack_left_shift_u32(src_p[0], 12u, 0xffu);
    ang_rate_raw_x |= unpack_left_shift_u32(src_p[1], 4u, 0xffu);
    ang_rate_raw_x |= unpack_right_shift_u32(src_p[2], 4u, 0xf0u);

    if ((ang_rate_raw_x & (1u << 19)) != 0u) {
        ang_rate_raw_x |= 0xfff00000u;
    }

    dst_p->ang_rate_raw_x = (int32_t)ang_rate_raw_x;
    ang_rate_raw_y = unpack_left_shift_u32(src_p[2], 16u, 0x0fu);
    ang_rate_raw_y |= unpack_left_shift_u32(src_p[3], 8u, 0xffu);
    ang_rate_raw_y |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);

    if ((ang_rate_raw_y & (1u << 19)) != 0u) {
        ang_rate_raw_y |= 0xfff00000u;
    }

    dst_p->ang_rate_raw_y = (int32_t)ang_rate_raw_y;
    ang_rate_raw_z = unpack_left_shift_u32(src_p[5], 12u, 0xffu);
    ang_rate_raw_z |= unpack_left_shift_u32(src_p[6], 4u, 0xffu);
    ang_rate_raw_z |= unpack_right_shift_u32(src_p[7], 4u, 0xf0u);

    if ((ang_rate_raw_z & (1u << 19)) != 0u) {
        ang_rate_raw_z |= 0xfff00000u;
    }

    dst_p->ang_rate_raw_z = (int32_t)ang_rate_raw_z;

    return (0);
}

int inu_ang_rate_raw_imu_init(struct inu_ang_rate_raw_imu_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct inu_ang_rate_raw_imu_t));

    return 0;
}

int32_t inu_ang_rate_raw_imu_ang_rate_raw_x_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_raw_imu_ang_rate_raw_x_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_raw_imu_ang_rate_raw_x_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}

int32_t inu_ang_rate_raw_imu_ang_rate_raw_y_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_raw_imu_ang_rate_raw_y_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_raw_imu_ang_rate_raw_y_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}

int32_t inu_ang_rate_raw_imu_ang_rate_raw_z_encode(double value)
{
    return (int32_t)(value / 0.01);
}

double inu_ang_rate_raw_imu_ang_rate_raw_z_decode(int32_t value)
{
    return ((double)value * 0.01);
}

bool inu_ang_rate_raw_imu_ang_rate_raw_z_is_in_range(int32_t value)
{
    return ((value >= -50000) && (value <= 50000));
}
