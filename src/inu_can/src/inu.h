/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.0 Wed Apr 10 14:17:48 2024.
 */

#ifndef INU_H
#define INU_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define INU_LATITUDE_FRAME_ID (0x32eu)
#define INU_LONGITUDE_FRAME_ID (0x32du)
#define INU_ANG_RATE_VEHICLE_FRAME_ID (0x32cu)
#define INU_HEADING_PITCH_ROLL_SIGMA_FRAME_ID (0x32bu)
#define INU_HEADING_PITCH_ROLL_FRAME_ID (0x32au)
#define INU_ACCEL_VEHICLE_FRAME_ID (0x329u)
#define INU_VELOCITY_LEVEL_SIGMA_FRAME_ID (0x328u)
#define INU_TIME_FRAME_ID (0x320u)
#define INU_VELOCITY_LEVEL_FRAME_ID (0x327u)
#define INU_POS_SIGMA_FRAME_ID (0x326u)
#define INU_ALTITUDE_FRAME_ID (0x325u)
#define INU_LATITUDE_LONGITUDE_FRAME_ID (0x324u)
#define INU_INS_STATUS_FRAME_ID (0x323u)
#define INU_ACCEL_IMU_RAW_FRAME_ID (0x322u)
#define INU_ANG_RATE_RAW_IMU_FRAME_ID (0x321u)

/* Frame lengths in bytes. */
#define INU_LATITUDE_LENGTH (8u)
#define INU_LONGITUDE_LENGTH (8u)
#define INU_ANG_RATE_VEHICLE_LENGTH (8u)
#define INU_HEADING_PITCH_ROLL_SIGMA_LENGTH (8u)
#define INU_HEADING_PITCH_ROLL_LENGTH (6u)
#define INU_ACCEL_VEHICLE_LENGTH (8u)
#define INU_VELOCITY_LEVEL_SIGMA_LENGTH (8u)
#define INU_TIME_LENGTH (6u)
#define INU_VELOCITY_LEVEL_LENGTH (8u)
#define INU_POS_SIGMA_LENGTH (8u)
#define INU_ALTITUDE_LENGTH (4u)
#define INU_LATITUDE_LONGITUDE_LENGTH (8u)
#define INU_INS_STATUS_LENGTH (8u)
#define INU_ACCEL_IMU_RAW_LENGTH (8u)
#define INU_ANG_RATE_RAW_IMU_LENGTH (8u)

/* Extended or standard frame types. */
#define INU_LATITUDE_IS_EXTENDED (0)
#define INU_LONGITUDE_IS_EXTENDED (0)
#define INU_ANG_RATE_VEHICLE_IS_EXTENDED (0)
#define INU_HEADING_PITCH_ROLL_SIGMA_IS_EXTENDED (0)
#define INU_HEADING_PITCH_ROLL_IS_EXTENDED (0)
#define INU_ACCEL_VEHICLE_IS_EXTENDED (0)
#define INU_VELOCITY_LEVEL_SIGMA_IS_EXTENDED (0)
#define INU_TIME_IS_EXTENDED (0)
#define INU_VELOCITY_LEVEL_IS_EXTENDED (0)
#define INU_POS_SIGMA_IS_EXTENDED (0)
#define INU_ALTITUDE_IS_EXTENDED (0)
#define INU_LATITUDE_LONGITUDE_IS_EXTENDED (0)
#define INU_INS_STATUS_IS_EXTENDED (0)
#define INU_ACCEL_IMU_RAW_IS_EXTENDED (0)
#define INU_ANG_RATE_RAW_IMU_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define INU_LATITUDE_NAME "Latitude"
#define INU_LONGITUDE_NAME "Longitude"
#define INU_ANG_RATE_VEHICLE_NAME "AngRateVehicle"
#define INU_HEADING_PITCH_ROLL_SIGMA_NAME "HeadingPitchRollSigma"
#define INU_HEADING_PITCH_ROLL_NAME "HeadingPitchRoll"
#define INU_ACCEL_VEHICLE_NAME "Accel_Vehicle"
#define INU_VELOCITY_LEVEL_SIGMA_NAME "VelocityLevelSigma"
#define INU_TIME_NAME "Time"
#define INU_VELOCITY_LEVEL_NAME "VelocityLevel"
#define INU_POS_SIGMA_NAME "PosSigma"
#define INU_ALTITUDE_NAME "Altitude"
#define INU_LATITUDE_LONGITUDE_NAME "LatitudeLongitude"
#define INU_INS_STATUS_NAME "InsStatus"
#define INU_ACCEL_IMU_RAW_NAME "Accel_IMU_Raw"
#define INU_ANG_RATE_RAW_IMU_NAME "Ang_Rate_Raw_IMU"

/* Signal Names. */
#define INU_LATITUDE_POS_LAT2_NAME "PosLat2"
#define INU_LONGITUDE_POS_LON2_NAME "PosLon2"
#define INU_ANG_RATE_VEHICLE_ANG_RATE_X_NAME "AngRateX"
#define INU_ANG_RATE_VEHICLE_ANG_RATE_Y_NAME "AngRateY"
#define INU_ANG_RATE_VEHICLE_ANG_RATE_Z_NAME "AngRateZ"
#define INU_HEADING_PITCH_ROLL_SIGMA_ANGLE_HEADING_SIGMA_NAME "AngleHeadingSigma"
#define INU_HEADING_PITCH_ROLL_SIGMA_ANGLE_PITCH_SIGMA_NAME "AnglePitchSigma"
#define INU_HEADING_PITCH_ROLL_SIGMA_ANGLE_ROLL_SIGMA_NAME "AngleRollSigma"
#define INU_HEADING_PITCH_ROLL_ANGLE_HEADING_NAME "AngleHeading"
#define INU_HEADING_PITCH_ROLL_ANGLE_PITCH_NAME "AnglePitch"
#define INU_HEADING_PITCH_ROLL_ANGLE_ROLL_NAME "AngleRoll"
#define INU_ACCEL_VEHICLE_ACCEL_X_NAME "AccelX"
#define INU_ACCEL_VEHICLE_ACCEL_Y_NAME "AccelY"
#define INU_ACCEL_VEHICLE_ACCEL_Z_NAME "AccelZ"
#define INU_VELOCITY_LEVEL_SIGMA_VEL_E_SIGMA_NAME "VelESigma"
#define INU_VELOCITY_LEVEL_SIGMA_VEL_N_SIGMA_NAME "VelNSigma"
#define INU_VELOCITY_LEVEL_SIGMA_VEL_U_SIGMA_NAME "VelUSigma"
#define INU_VELOCITY_LEVEL_SIGMA_VEL_SIGMA_NAME "VelSigma"
#define INU_TIME_GPS_WEEK_NAME "GpsWeek"
#define INU_TIME_GPS_TIME_NAME "GpsTime"
#define INU_VELOCITY_LEVEL_VEL_E_NAME "VelE"
#define INU_VELOCITY_LEVEL_VEL_N_NAME "VelN"
#define INU_VELOCITY_LEVEL_VEL_U_NAME "VelU"
#define INU_VELOCITY_LEVEL_VEL_NAME "Vel"
#define INU_POS_SIGMA_POS_E_SIGMA_NAME "PosESigma"
#define INU_POS_SIGMA_POS_NSIGMA_NAME "PosNsigma"
#define INU_POS_SIGMA_POS_USIGMA_NAME "PosUsigma"
#define INU_ALTITUDE_POS_ALT_NAME "PosAlt"
#define INU_LATITUDE_LONGITUDE_POS_LAT_NAME "PosLat"
#define INU_LATITUDE_LONGITUDE_POS_LON_NAME "PosLon"
#define INU_INS_STATUS_SYSTEM_STATE_NAME "system_state"
#define INU_INS_STATUS_GPS_NUM_SATS_USED_NAME "GpsNumSatsUsed"
#define INU_INS_STATUS_SATELLITE_STATUS_NAME "satellite_status"
#define INU_INS_STATUS_GPS_NUM_SATS2_USED_NAME "GpsNumSats2Used"
#define INU_INS_STATUS_GPS_AGE_NAME "GpsAge"
#define INU_INS_STATUS_GPS_NUM_SATS_NAME "GpsNumSats"
#define INU_INS_STATUS_GPS_NUM_SATS2_NAME "GpsNumSats2"
#define INU_ACCEL_IMU_RAW_ACCEL_RAW_X_NAME "AccelRawX"
#define INU_ACCEL_IMU_RAW_ACCEL_RAW_Y_NAME "AccelRawY"
#define INU_ACCEL_IMU_RAW_ACCEL_RAW_Z_NAME "AccelRawZ"
#define INU_ANG_RATE_RAW_IMU_ANG_RATE_RAW_X_NAME "AngRateRawX"
#define INU_ANG_RATE_RAW_IMU_ANG_RATE_RAW_Y_NAME "AngRateRawY"
#define INU_ANG_RATE_RAW_IMU_ANG_RATE_RAW_Z_NAME "AngRateRawZ"

/**
 * Signals in message Latitude.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_latitude_t {
    /**
     * Range: -9000000000..9000000000 (-90..90 deg)
     * Scale: 1e-08
     * Offset: 0
     */
    int64_t pos_lat2;
};

/**
 * Signals in message Longitude.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_longitude_t {
    /**
     * Range: -18000000000..18000000000 (-180..180 deg)
     * Scale: 1e-08
     * Offset: 0
     */
    int64_t pos_lon2;
};

/**
 * Signals in message AngRateVehicle.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_ang_rate_vehicle_t {
    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_x;

    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_y;

    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_z;
};

/**
 * Signals in message HeadingPitchRollSigma.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_heading_pitch_roll_sigma_t {
    /**
     * Range: 0..1000000 (0..100 deg)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t angle_heading_sigma;

    /**
     * Range: 0..1000000 (0..100 deg)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t angle_pitch_sigma;

    /**
     * Range: 0..1000000 (0..100 deg)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t angle_roll_sigma;
};

/**
 * Signals in message HeadingPitchRoll.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_heading_pitch_roll_t {
    /**
     * Range: 0..36000 (0..360 deg)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t angle_heading;

    /**
     * Range: -9000..9000 (-90..90 deg)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t angle_pitch;

    /**
     * Range: -18000..18000 (-180..180 deg)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t angle_roll;
};

/**
 * Signals in message Accel_Vehicle.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_accel_vehicle_t {
    /**
     * Range: -80000..80000 (-8..8 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_x;

    /**
     * Range: -80000..80000 (-8..8 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_y;

    /**
     * Range: -80000..80000 (-8..8 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_z;
};

/**
 * Signals in message VelocityLevelSigma.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_velocity_level_sigma_t {
    /**
     * Range: 0..65535 (0..65.535 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t vel_e_sigma;

    /**
     * Range: 0..65535 (0..65.535 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t vel_n_sigma;

    /**
     * Range: 0..65535 (0..65.535 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t vel_u_sigma;

    /**
     * Range: 0..65535 (0..65.535 m/s)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t vel_sigma;
};

/**
 * Signals in message Time.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_time_t {
    /**
     * Range: 0..65535 (0..65535 w)
     * Scale: 1
     * Offset: 0
     */
    uint16_t gps_week;

    /**
     * Range: 0..4294967295 (0..4294967.295 s)
     * Scale: 0.001
     * Offset: 0
     */
    uint32_t gps_time;
};

/**
 * Signals in message VelocityLevel.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_velocity_level_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t vel_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t vel_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t vel_u;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t vel;
};

/**
 * Signals in message PosSigma.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_pos_sigma_t {
    /**
     * Range: 0..1000000 (0..100 m)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t pos_e_sigma;

    /**
     * Range: 0..1000000 (0..100 m)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t pos_nsigma;

    /**
     * Range: 0..1000000 (0..100 m)
     * Scale: 0.0001
     * Offset: 0
     */
    uint32_t pos_usigma;
};

/**
 * Signals in message Altitude.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_altitude_t {
    /**
     * Range: -2147483648..2147483648 (-2147483.648..2147483.648 m)
     * Scale: 0.001
     * Offset: 0
     */
    int32_t pos_alt;
};

/**
 * Signals in message LatitudeLongitude.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_latitude_longitude_t {
    /**
     * Range: -2147483648..2147483648 (-214.74836..214.74836 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t pos_lat;

    /**
     * Range: -2147483648..2147483648 (-214.74836..214.74836 deg)
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t pos_lon;
};

/**
 * Signals in message InsStatus.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_ins_status_t {
    /**
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t system_state;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_num_sats_used;

    /**
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t satellite_status;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_num_sats2_used;

    /**
     * Range: 0..65535 (0..655.35 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t gps_age;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_num_sats;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_num_sats2;
};

/**
 * Signals in message Accel_IMU_Raw.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_accel_imu_raw_t {
    /**
     * Range: -500000..500000 (-50..50 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_raw_x;

    /**
     * Range: -500000..500000 (-50..50 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_raw_y;

    /**
     * Range: -500000..500000 (-50..50 g)
     * Scale: 0.0001
     * Offset: 0
     */
    int32_t accel_raw_z;
};

/**
 * Signals in message Ang_Rate_Raw_IMU.
 *
 * All signal values are as on the CAN bus.
 */
struct inu_ang_rate_raw_imu_t {
    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_raw_x;

    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_raw_y;

    /**
     * Range: -50000..50000 (-500..500 deg/s)
     * Scale: 0.01
     * Offset: 0
     */
    int32_t ang_rate_raw_z;
};

/**
 * Pack message Latitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_latitude_pack(
    uint8_t *dst_p,
    const struct inu_latitude_t *src_p,
    size_t size);

/**
 * Unpack message Latitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_latitude_unpack(
    struct inu_latitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Latitude.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_latitude_init(struct inu_latitude_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t inu_latitude_pos_lat2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_latitude_pos_lat2_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_latitude_pos_lat2_is_in_range(int64_t value);

/**
 * Pack message Longitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_longitude_pack(
    uint8_t *dst_p,
    const struct inu_longitude_t *src_p,
    size_t size);

/**
 * Unpack message Longitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_longitude_unpack(
    struct inu_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Longitude.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_longitude_init(struct inu_longitude_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t inu_longitude_pos_lon2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_longitude_pos_lon2_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_longitude_pos_lon2_is_in_range(int64_t value);

/**
 * Pack message AngRateVehicle.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_ang_rate_vehicle_pack(
    uint8_t *dst_p,
    const struct inu_ang_rate_vehicle_t *src_p,
    size_t size);

/**
 * Unpack message AngRateVehicle.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_ang_rate_vehicle_unpack(
    struct inu_ang_rate_vehicle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AngRateVehicle.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_ang_rate_vehicle_init(struct inu_ang_rate_vehicle_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_vehicle_ang_rate_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_vehicle_ang_rate_x_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_vehicle_ang_rate_x_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_vehicle_ang_rate_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_vehicle_ang_rate_y_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_vehicle_ang_rate_y_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_vehicle_ang_rate_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_vehicle_ang_rate_z_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_vehicle_ang_rate_z_is_in_range(int32_t value);

/**
 * Pack message HeadingPitchRollSigma.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_heading_pitch_roll_sigma_pack(
    uint8_t *dst_p,
    const struct inu_heading_pitch_roll_sigma_t *src_p,
    size_t size);

/**
 * Unpack message HeadingPitchRollSigma.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_heading_pitch_roll_sigma_unpack(
    struct inu_heading_pitch_roll_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HeadingPitchRollSigma.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_heading_pitch_roll_sigma_init(struct inu_heading_pitch_roll_sigma_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_heading_pitch_roll_sigma_angle_heading_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_sigma_angle_heading_sigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_sigma_angle_heading_sigma_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_heading_pitch_roll_sigma_angle_pitch_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_sigma_angle_pitch_sigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_sigma_angle_pitch_sigma_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_heading_pitch_roll_sigma_angle_roll_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_sigma_angle_roll_sigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_sigma_angle_roll_sigma_is_in_range(uint32_t value);

/**
 * Pack message HeadingPitchRoll.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_heading_pitch_roll_pack(
    uint8_t *dst_p,
    const struct inu_heading_pitch_roll_t *src_p,
    size_t size);

/**
 * Unpack message HeadingPitchRoll.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_heading_pitch_roll_unpack(
    struct inu_heading_pitch_roll_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from HeadingPitchRoll.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_heading_pitch_roll_init(struct inu_heading_pitch_roll_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_heading_pitch_roll_angle_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_angle_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_angle_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_heading_pitch_roll_angle_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_angle_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_angle_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_heading_pitch_roll_angle_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_heading_pitch_roll_angle_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_heading_pitch_roll_angle_roll_is_in_range(int16_t value);

/**
 * Pack message Accel_Vehicle.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_accel_vehicle_pack(
    uint8_t *dst_p,
    const struct inu_accel_vehicle_t *src_p,
    size_t size);

/**
 * Unpack message Accel_Vehicle.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_accel_vehicle_unpack(
    struct inu_accel_vehicle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Accel_Vehicle.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_accel_vehicle_init(struct inu_accel_vehicle_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_vehicle_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_vehicle_accel_x_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_vehicle_accel_x_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_vehicle_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_vehicle_accel_y_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_vehicle_accel_y_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_vehicle_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_vehicle_accel_z_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_vehicle_accel_z_is_in_range(int32_t value);

/**
 * Pack message VelocityLevelSigma.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_velocity_level_sigma_pack(
    uint8_t *dst_p,
    const struct inu_velocity_level_sigma_t *src_p,
    size_t size);

/**
 * Unpack message VelocityLevelSigma.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_velocity_level_sigma_unpack(
    struct inu_velocity_level_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VelocityLevelSigma.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_velocity_level_sigma_init(struct inu_velocity_level_sigma_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_velocity_level_sigma_vel_e_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_sigma_vel_e_sigma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_sigma_vel_e_sigma_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_velocity_level_sigma_vel_n_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_sigma_vel_n_sigma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_sigma_vel_n_sigma_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_velocity_level_sigma_vel_u_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_sigma_vel_u_sigma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_sigma_vel_u_sigma_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_velocity_level_sigma_vel_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_sigma_vel_sigma_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_sigma_vel_sigma_is_in_range(uint16_t value);

/**
 * Pack message Time.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_time_pack(
    uint8_t *dst_p,
    const struct inu_time_t *src_p,
    size_t size);

/**
 * Unpack message Time.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_time_unpack(
    struct inu_time_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Time.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_time_init(struct inu_time_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_time_gps_week_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_time_gps_week_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_time_gps_week_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_time_gps_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_time_gps_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_time_gps_time_is_in_range(uint32_t value);

/**
 * Pack message VelocityLevel.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_velocity_level_pack(
    uint8_t *dst_p,
    const struct inu_velocity_level_t *src_p,
    size_t size);

/**
 * Unpack message VelocityLevel.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_velocity_level_unpack(
    struct inu_velocity_level_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VelocityLevel.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_velocity_level_init(struct inu_velocity_level_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_velocity_level_vel_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_vel_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_vel_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_velocity_level_vel_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_vel_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_vel_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_velocity_level_vel_u_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_vel_u_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_vel_u_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t inu_velocity_level_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_velocity_level_vel_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_velocity_level_vel_is_in_range(int16_t value);

/**
 * Pack message PosSigma.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_pos_sigma_pack(
    uint8_t *dst_p,
    const struct inu_pos_sigma_t *src_p,
    size_t size);

/**
 * Unpack message PosSigma.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_pos_sigma_unpack(
    struct inu_pos_sigma_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PosSigma.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_pos_sigma_init(struct inu_pos_sigma_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_pos_sigma_pos_e_sigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_pos_sigma_pos_e_sigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_pos_sigma_pos_e_sigma_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_pos_sigma_pos_nsigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_pos_sigma_pos_nsigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_pos_sigma_pos_nsigma_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t inu_pos_sigma_pos_usigma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_pos_sigma_pos_usigma_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_pos_sigma_pos_usigma_is_in_range(uint32_t value);

/**
 * Pack message Altitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_altitude_pack(
    uint8_t *dst_p,
    const struct inu_altitude_t *src_p,
    size_t size);

/**
 * Unpack message Altitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_altitude_unpack(
    struct inu_altitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Altitude.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_altitude_init(struct inu_altitude_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_altitude_pos_alt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_altitude_pos_alt_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_altitude_pos_alt_is_in_range(int32_t value);

/**
 * Pack message LatitudeLongitude.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_latitude_longitude_pack(
    uint8_t *dst_p,
    const struct inu_latitude_longitude_t *src_p,
    size_t size);

/**
 * Unpack message LatitudeLongitude.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_latitude_longitude_unpack(
    struct inu_latitude_longitude_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LatitudeLongitude.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_latitude_longitude_init(struct inu_latitude_longitude_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_latitude_longitude_pos_lat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_latitude_longitude_pos_lat_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_latitude_longitude_pos_lat_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_latitude_longitude_pos_lon_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_latitude_longitude_pos_lon_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_latitude_longitude_pos_lon_is_in_range(int32_t value);

/**
 * Pack message InsStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_ins_status_pack(
    uint8_t *dst_p,
    const struct inu_ins_status_t *src_p,
    size_t size);

/**
 * Unpack message InsStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_ins_status_unpack(
    struct inu_ins_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from InsStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_ins_status_init(struct inu_ins_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_system_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_system_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_system_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_gps_num_sats_used_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_gps_num_sats_used_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_gps_num_sats_used_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_satellite_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_satellite_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_satellite_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_gps_num_sats2_used_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_gps_num_sats2_used_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_gps_num_sats2_used_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t inu_ins_status_gps_age_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_gps_age_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_gps_age_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_gps_num_sats_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_gps_num_sats_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_gps_num_sats_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t inu_ins_status_gps_num_sats2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ins_status_gps_num_sats2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ins_status_gps_num_sats2_is_in_range(uint8_t value);

/**
 * Pack message Accel_IMU_Raw.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_accel_imu_raw_pack(
    uint8_t *dst_p,
    const struct inu_accel_imu_raw_t *src_p,
    size_t size);

/**
 * Unpack message Accel_IMU_Raw.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_accel_imu_raw_unpack(
    struct inu_accel_imu_raw_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Accel_IMU_Raw.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_accel_imu_raw_init(struct inu_accel_imu_raw_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_imu_raw_accel_raw_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_imu_raw_accel_raw_x_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_imu_raw_accel_raw_x_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_imu_raw_accel_raw_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_imu_raw_accel_raw_y_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_imu_raw_accel_raw_y_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_accel_imu_raw_accel_raw_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_accel_imu_raw_accel_raw_z_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_accel_imu_raw_accel_raw_z_is_in_range(int32_t value);

/**
 * Pack message Ang_Rate_Raw_IMU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int inu_ang_rate_raw_imu_pack(
    uint8_t *dst_p,
    const struct inu_ang_rate_raw_imu_t *src_p,
    size_t size);

/**
 * Unpack message Ang_Rate_Raw_IMU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int inu_ang_rate_raw_imu_unpack(
    struct inu_ang_rate_raw_imu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Ang_Rate_Raw_IMU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int inu_ang_rate_raw_imu_init(struct inu_ang_rate_raw_imu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_raw_imu_ang_rate_raw_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_raw_imu_ang_rate_raw_x_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_raw_imu_ang_rate_raw_x_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_raw_imu_ang_rate_raw_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_raw_imu_ang_rate_raw_y_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_raw_imu_ang_rate_raw_y_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t inu_ang_rate_raw_imu_ang_rate_raw_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double inu_ang_rate_raw_imu_ang_rate_raw_z_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool inu_ang_rate_raw_imu_ang_rate_raw_z_is_in_range(int32_t value);


#ifdef __cplusplus
}
#endif

#endif
